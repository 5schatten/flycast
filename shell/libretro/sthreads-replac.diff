diff --git a/core/hw/pvr/drkPvr.cpp b/core/hw/pvr/drkPvr.cpp
index d5949ed..7346f96 100644
--- a/core/hw/pvr/drkPvr.cpp
+++ b/core/hw/pvr/drkPvr.cpp
@@ -34,6 +34,8 @@ void libPvr_Reset(bool Manual)
 
 s32 libPvr_Init(void)
 {
+   if (!tactx_Init())
+      return rv_error;
    //failed
 	if (!spg_Init())
 		return rv_error;
@@ -47,6 +49,7 @@ s32 libPvr_Init(void)
 //called when exiting from sh4 thread , from the new thread context (for any thread specific de init) :P
 void libPvr_Term(void)
 {
+   tactx_Free();
 	rend_term();
 	spg_Term();
 }
diff --git a/core/hw/pvr/ta_ctx.cpp b/core/hw/pvr/ta_ctx.cpp
index 54ab2df..aa98f5f 100644
--- a/core/hw/pvr/ta_ctx.cpp
+++ b/core/hw/pvr/ta_ctx.cpp
@@ -52,7 +52,7 @@ bool TryDecodeTARC(void)
 		vd_ctx->rend.proc_start = vd_ctx->rend.proc_end + 32;
 		vd_ctx->rend.proc_end = vd_ctx->tad.thd_data;
 			
-		vd_ctx->rend_inuse.Lock();
+      slock_lock(vd_ctx->rend_inuse);
 		vd_rc = vd_ctx->rend;
 
 		//signal the vdec thread
@@ -67,12 +67,12 @@ void VDecEnd(void)
 
 	vd_ctx->rend = vd_rc;
 
-	vd_ctx->rend_inuse.Unlock();
+   slock_unlock(vd_ctx->rend_inuse);
 
 	vd_ctx = 0;
 }
 
-cMutex mtx_rqueue;
+slock_t *mtx_rqueue;
 TA_context* rqueue;
 cResetEvent frame_finished(false, true);
 
@@ -116,10 +116,10 @@ bool QueueRender(TA_context* ctx)
 	}
 
 	frame_finished.Reset();
-	mtx_rqueue.Lock();
+   slock_lock(mtx_rqueue);
 	TA_context* old = rqueue;
 	rqueue=ctx;
-	mtx_rqueue.Unlock();
+   slock_unlock(mtx_rqueue);
 
 	verify(!old);
 
@@ -128,9 +128,9 @@ bool QueueRender(TA_context* ctx)
 
 TA_context* DequeueRender(void)
 {
-	mtx_rqueue.Lock();
+   slock_lock(mtx_rqueue);
 	TA_context* rv = rqueue;
-	mtx_rqueue.Unlock();
+   slock_unlock(mtx_rqueue);
 
 	if (rv)
 		FrameCount++;
@@ -140,9 +140,9 @@ TA_context* DequeueRender(void)
 
 bool rend_framePending(void)
 {
-	mtx_rqueue.Lock();
+   slock_lock(mtx_rqueue);
 	TA_context* rv = rqueue;
-	mtx_rqueue.Unlock();
+   slock_unlock(mtx_rqueue);
 
 	return rv != 0;
 }
@@ -150,15 +150,15 @@ bool rend_framePending(void)
 void FinishRender(TA_context* ctx)
 {
 	verify(rqueue == ctx);
-	mtx_rqueue.Lock();
+   slock_lock(mtx_rqueue);
 	rqueue = 0;
-	mtx_rqueue.Unlock();
+   slock_unlock(mtx_rqueue);
 
 	tactx_Recycle(ctx);
 	frame_finished.Set();
 }
 
-cMutex mtx_pool;
+slock_t *mtx_pool;
 
 vector<TA_context*> ctx_pool;
 vector<TA_context*> ctx_list;
@@ -167,13 +167,13 @@ TA_context* tactx_Alloc(void)
 {
 	TA_context* rv = 0;
 
-	mtx_pool.Lock();
+   slock_lock(mtx_pool);
 	if (ctx_pool.size())
 	{
 		rv = ctx_pool[ctx_pool.size()-1];
 		ctx_pool.pop_back();
 	}
-	mtx_pool.Unlock();
+   slock_unlock(mtx_pool);
 	
 	if (!rv)
 	{
@@ -187,7 +187,7 @@ TA_context* tactx_Alloc(void)
 
 void tactx_Recycle(TA_context* poped_ctx)
 {
-	mtx_pool.Lock();
+   slock_lock(mtx_pool);
 	{
 		if (ctx_pool.size()>2)
 		{
@@ -200,7 +200,7 @@ void tactx_Recycle(TA_context* poped_ctx)
 			ctx_pool.push_back(poped_ctx);
 		}
 	}
-	mtx_pool.Unlock();
+   slock_unlock(mtx_pool);
 }
 
 TA_context* tactx_Find(u32 addr, bool allocnew)
@@ -241,3 +241,19 @@ TA_context* tactx_Pop(u32 addr)
 	}
 	return 0;
 }
+
+void tactx_Free(void)
+{
+   slock_free(mtx_rqueue);
+   slock_free(mtx_pool);
+   mtx_rqueue = NULL;
+   mtx_pool   = NULL;
+}
+
+bool tactx_Init(void)
+{
+   mtx_rqueue = slock_new();
+   mtx_pool   = slock_new();
+
+   return true;
+}
diff --git a/core/hw/pvr/ta_ctx.h b/core/hw/pvr/ta_ctx.h
index 6317956..e74c3f5 100644
--- a/core/hw/pvr/ta_ctx.h
+++ b/core/hw/pvr/ta_ctx.h
@@ -1,6 +1,7 @@
 #pragma once
 #include "ta.h"
 #include "pvr_regs.h"
+#include <rthreads/rthreads.h>
 
 //Vertex storage types
 struct Vertex
@@ -121,8 +122,8 @@ struct TA_context
 	u32 Address;
 	u32 LastUsed;
 
-	cMutex thd_inuse;
-	cMutex rend_inuse;
+   slock_t *thd_inuse;
+   slock_t *rend_inuse;
 
 	tad_context tad;
 	rend_context rend;
@@ -168,10 +169,10 @@ struct TA_context
 	void Reset()
 	{
 		tad.Clear();
-		rend_inuse.Lock();
+      slock_lock(rend_inuse);
 		rend.Clear();
 		rend.proc_end = rend.proc_start = tad.thd_root;
-		rend_inuse.Unlock();
+      slock_unlock(rend_inuse);
 	}
 
 	void Free()
@@ -217,4 +218,6 @@ void VDecEnd();
 
 //must be moved to proper header
 void FillBGP(TA_context* ctx);
-bool UsingAutoSort();
\ No newline at end of file
+bool UsingAutoSort();
+void tactx_Free(void);
+bool tactx_Init(void);
diff --git a/core/hw/pvr/ta_vtx.cpp b/core/hw/pvr/ta_vtx.cpp
index dc95063..0ca8407 100644
--- a/core/hw/pvr/ta_vtx.cpp
+++ b/core/hw/pvr/ta_vtx.cpp
@@ -1463,7 +1463,7 @@ bool ta_parse_vdrc(TA_context* ctx)
 
 	vd_ctx->rend = vd_rc;
 	vd_ctx = 0;
-	ctx->rend_inuse.Unlock();
+   slock_unlock(ctx->rend_inuse);
 
 	return rv;
 }
diff --git a/core/rend/TexCache.cpp b/core/rend/TexCache.cpp
index 69039fd..ccf4ff6 100644
--- a/core/rend/TexCache.cpp
+++ b/core/rend/TexCache.cpp
@@ -1,6 +1,7 @@
 #include "TexCache.h"
 #include "hw/pvr/pvr_regs.h"
 #include "hw/mem/_vmem.h"
+#include <rthreads/rthreads.h>
 
 u8* vq_codebook;
 u32 palette_index;
@@ -154,7 +155,7 @@ added_it:
 	}
 }
  
-cMutex vramlist_lock;
+slock_t *vramlist_lock;
 
 //simple IsInRange test
 inline bool IsInRange(vram_block* block,u32 offset)
@@ -190,7 +191,7 @@ vram_block* libCore_vramlock_Lock(u32 start_offset64,u32 end_offset64,void* user
 	block->type=64;
 
 	{
-		vramlist_lock.Lock();
+      slock_lock(vramlist_lock);
 	
 		vram.LockRegion(block->start,block->len);
 
@@ -201,7 +202,7 @@ vram_block* libCore_vramlock_Lock(u32 start_offset64,u32 end_offset64,void* user
 		
 		vramlock_list_add(block);
 		
-		vramlist_lock.Unlock();
+      slock_unlock(vramlist_lock);
 	}
 
 	return block;
@@ -219,7 +220,7 @@ bool VramLockedWrite(u8* address)
 		vector<vram_block*>* list=&VramLocks[addr_hash];
 		
 		{
-			vramlist_lock.Lock();
+         slock_lock(vramlist_lock);
 
 			for (size_t i=0;i<list->size();i++)
 			{
@@ -244,22 +245,22 @@ bool VramLockedWrite(u8* address)
 				vram.UnLockRegion((u32)offset&(~(PAGE_SIZE-1)) + VRAM_SIZE,PAGE_SIZE);
 			}
 			
-			vramlist_lock.Unlock();
+         slock_unlock(vramlist_lock);
 		}
 
 		return true;
 	}
-	else
-		return false;
+
+   return false;
 }
 
 //unlocks mem
 //also frees the handle
 void libCore_vramlock_Unlock_block(vram_block* block)
 {
-	vramlist_lock.Lock();
+   slock_lock(vramlist_lock);
 	libCore_vramlock_Unlock_block_wb(block);
-	vramlist_lock.Unlock();
+   slock_unlock(vramlist_lock);
 }
 
 void libCore_vramlock_Unlock_block_wb(vram_block* block)
@@ -273,4 +274,17 @@ void libCore_vramlock_Unlock_block_wb(vram_block* block)
 		//more work needed
 		free(block);
 	}
-}
\ No newline at end of file
+}
+
+void libCore_Free(void)
+{
+   slock_free(vramlist_lock);
+   vramlist_lock = NULL;
+}
+
+bool libCore_Init(void)
+{
+   vramlist_lock = slock_new();
+
+   return true;
+}
diff --git a/core/rend/TexCache.h b/core/rend/TexCache.h
index b736dc2..c2090fc 100644
--- a/core/rend/TexCache.h
+++ b/core/rend/TexCache.h
@@ -451,4 +451,7 @@ void vramlock_Unlock_block(vram_block* block);
 vram_block* vramlock_Lock_32(u32 start_offset32,u32 end_offset32,void* userdata);
 vram_block* vramlock_Lock_64(u32 start_offset64,u32 end_offset64,void* userdata);
 
-void vram_LockedWrite(u32 offset64);
\ No newline at end of file
+void vram_LockedWrite(u32 offset64);
+
+void libCore_Free(void);
+bool libCore_Init(void);
diff --git a/core/rend/gles/gles.cpp b/core/rend/gles/gles.cpp
index 2ba2ec7..90e9627 100755
--- a/core/rend/gles/gles.cpp
+++ b/core/rend/gles/gles.cpp
@@ -5,6 +5,8 @@
 
 #include <GL3/gl3w.c>
 
+#include <rthreads/rthreads.h>
+
 /*
 GL|ES 2
 Slower, smaller subset of gl2
@@ -785,7 +787,7 @@ bool ProcessFrame(TA_context* ctx)
 	if (ctx->rend.isRTT)
 		return false;
 
-	ctx->rend_inuse.Lock();
+   slock_lock(ctx->rend_inuse);
 	ctx->MarkRend();
 
 	if (KillTex)
diff --git a/core/rend/gles/gles_libretro.cpp b/core/rend/gles/gles_libretro.cpp
index 33cb1e5..c723705 100755
--- a/core/rend/gles/gles_libretro.cpp
+++ b/core/rend/gles/gles_libretro.cpp
@@ -595,7 +595,7 @@ bool ProcessFrame(TA_context* ctx)
 	if (ctx->rend.isRTT)
 		return false;
 
-	ctx->rend_inuse.Lock();
+   slock_lock(ctx->rend_inuse);
 	ctx->MarkRend();
 
 	if (KillTex)
diff --git a/core/rend/gles/gltex.cpp b/core/rend/gles/gltex.cpp
index f19aa61..5cca7dc 100644
--- a/core/rend/gles/gltex.cpp
+++ b/core/rend/gles/gltex.cpp
@@ -1,6 +1,6 @@
 #include "gles.h"
-#include "rend/TexCache.h"
 #include "hw/pvr/pvr_mem.h"
+#include "../TexCache.h"
 
 #include <memalign.h>
 
@@ -129,6 +129,7 @@ struct TextureCacheData
 	//Create GL texture from tsp/tcw
 	void Create(bool isGL)
 	{
+      libCore_Init();
 		//ask GL for texture ID
 		if (isGL) {
 			glGenTextures(1, &texID);
@@ -355,6 +356,7 @@ struct TextureCacheData
       }
 		if (lock_block)
 			libCore_vramlock_Unlock_block(lock_block);
+      libCore_Free();
 		lock_block=0;
 	}
 };
diff --git a/core/rend/soft/softrend.cpp b/core/rend/soft/softrend.cpp
index d816d64..f32a4e6 100644
--- a/core/rend/soft/softrend.cpp
+++ b/core/rend/soft/softrend.cpp
@@ -2,6 +2,7 @@
 #include "hw\pvr\Renderer_if.h"
 #include "hw\pvr\pvr_mem.h"
 #include "oslib\oslib.h"
+#include <rthreads/rthreads.h>
 
 /*
 	SSE/MMX based softrend
@@ -796,7 +797,7 @@ struct softrend : Renderer
 		if (ctx->rend.isRTT)
 			return false;
 
-		ctx->rend_inuse.Lock();
+      slock_lock(ctx->rend_inuse);
 		ctx->MarkRend();
 
 		if (!ta_parse_vdrc(ctx))
@@ -1158,4 +1159,4 @@ struct softrend : Renderer
 
 Renderer* rend_softrend() {
 	return new(_mm_malloc(sizeof(softrend), 32)) softrend();
-}
\ No newline at end of file
+}
diff --git a/core/stdclass.h b/core/stdclass.h
index 8becace..6e184af 100644
--- a/core/stdclass.h
+++ b/core/stdclass.h
@@ -190,31 +190,6 @@ public :
 	void Wait();	//Wait for signal , then reset[if auto]
 };
 
-class cMutex
-{
-private:
-   slock_t *mutx;
-
-public :
-	bool state;
-	cMutex()
-	{
-      mutx = slock_new();
-	}
-	~cMutex()
-	{
-      slock_free(mutx);
-	}
-	void Lock()
-	{
-      slock_lock(mutx);
-	}
-	void Unlock()
-	{
-      slock_unlock(mutx);
-	}
-};
-
 //Set the path !
 void set_user_config_dir(const string& dir);
 void set_user_data_dir(const string& dir);
