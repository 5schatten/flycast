diff --git a/core/hw/pvr/Renderer_if.cpp b/core/hw/pvr/Renderer_if.cpp
index d0bc5a3..2bc6d22 100644
--- a/core/hw/pvr/Renderer_if.cpp
+++ b/core/hw/pvr/Renderer_if.cpp
@@ -226,8 +226,8 @@ void rend_end_wait()
 bool rend_init(void)
 {
 
-#ifdef NO_REND
-	renderer	 = rend_norend();
+#if 1
+	renderer	 = rend_softrend();
 #else
 	renderer = rend_GLES2();
 #endif
diff --git a/core/linux-dist/x11.cpp b/core/linux-dist/x11.cpp
index cd23568..2cecef4 100644
--- a/core/linux-dist/x11.cpp
+++ b/core/linux-dist/x11.cpp
@@ -27,9 +27,13 @@ map<int, int> x11_keymap;
 int x11_dc_buttons = 0xFFFF;
 int x11_keyboard_input = 0;
 
+int x11_width;
+int x11_height;
+
 int ndcid = 0;
 void* x11_glc;
 bool x11_fullscreen = false;
+void *x11_vis;
 
 enum
 {
@@ -270,8 +274,8 @@ void x11_window_create()
 		sWA.event_mask = StructureNotifyMask | ExposureMask | ButtonPressMask | ButtonReleaseMask | KeyPressMask | KeyReleaseMask;
 		ui32Mask = CWBackPixel | CWBorderPixel | CWEventMask | CWColormap;
 
-		int x11_width = cfgLoadInt("x11", "width", DEFAULT_WINDOW_WIDTH);
-		int x11_height = cfgLoadInt("x11", "height", DEFAULT_WINDOW_HEIGHT);
+		x11_width      = cfgLoadInt("x11", "width", DEFAULT_WINDOW_WIDTH);
+		x11_height     = cfgLoadInt("x11", "height", DEFAULT_WINDOW_HEIGHT);
 		x11_fullscreen = (cfgLoadInt("x11", "fullscreen", DEFAULT_FULLSCREEN) > 0);
 
 		if (x11_width < 0 || x11_height < 0)
@@ -326,6 +330,7 @@ void x11_window_create()
 		//(EGLNativeDisplayType)x11Display;
 		x11_disp = (void*)x11Display;
 		x11_win = (void*)x11Window;
+      x11_vis = (void*)x11Visual->visual;
 	}
 	else
 	{
diff --git a/core/rend/gles/gltex.cpp b/core/rend/gles/gltex.cpp
index 14c12e7..9e0b67a 100644
--- a/core/rend/gles/gltex.cpp
+++ b/core/rend/gles/gltex.cpp
@@ -2,8 +2,6 @@
 #include "rend/TexCache.h"
 #include "hw/pvr/pvr_mem.h"
 
-#include <memalign.h>
-
 /*
 Textures
 
@@ -22,6 +20,8 @@ Compression
 	look into it, but afaik PVRC is not realtime doable
 */
 
+#include <xmmintrin.h>
+
 u16 temp_tex_buffer[1024*1024];
 extern u32 decoded_colors[3][65536];
 
@@ -309,32 +309,30 @@ struct TextureCacheData
 			if (tcw.MipMapped && settings.rend.UseMipmaps)
 				glGenerateMipmap(GL_TEXTURE_2D);
 		}
-#if 0
-		else
-      {
-				if (textype == GL_UNSIGNED_SHORT_5_6_5)
-					tex_type = 0;
-				else if (textype == GL_UNSIGNED_SHORT_5_5_5_1)
-					tex_type = 1;
-				else if (textype == GL_UNSIGNED_SHORT_4_4_4_4)
-					tex_type = 2;
-	
-				if (pData)
-					memalign_free(pData);
-	
-				pData = (u16*)memalign_alloc(16, w * h * 16);
-				for (int y = 0; y < h; y++) {
-					for (int x = 0; x < w; x++) {
-						u32* data = (u32*)&pData[(x + y*w) * 8];
-	
-						data[0] = decoded_colors[tex_type][temp_tex_buffer[(x + 1) % w + (y + 1) % h * w]];
-						data[1] = decoded_colors[tex_type][temp_tex_buffer[(x + 0) % w + (y + 1) % h * w]];
-						data[2] = decoded_colors[tex_type][temp_tex_buffer[(x + 1) % w + (y + 0) % h * w]];
-						data[3] = decoded_colors[tex_type][temp_tex_buffer[(x + 0) % w + (y + 0) % h * w]];
-					}
+		else {
+			if (textype == GL_UNSIGNED_SHORT_5_6_5)
+				tex_type = 0;
+			else if (textype == GL_UNSIGNED_SHORT_5_5_5_1)
+				tex_type = 1;
+			else if (textype == GL_UNSIGNED_SHORT_4_4_4_4)
+				tex_type = 2;
+
+			if (pData) {
+				_mm_free(pData);
+			}
+
+			pData = (u16*)_mm_malloc(w * h * 16, 16);
+			for (int y = 0; y < h; y++) {
+				for (int x = 0; x < w; x++) {
+					u32* data = (u32*)&pData[(x + y*w) * 8];
+
+					data[0] = decoded_colors[tex_type][temp_tex_buffer[(x + 1) % w + (y + 1) % h * w]];
+					data[1] = decoded_colors[tex_type][temp_tex_buffer[(x + 0) % w + (y + 1) % h * w]];
+					data[2] = decoded_colors[tex_type][temp_tex_buffer[(x + 1) % w + (y + 0) % h * w]];
+					data[3] = decoded_colors[tex_type][temp_tex_buffer[(x + 0) % w + (y + 0) % h * w]];
 				}
+			}
 		}
-#endif
 	}
 
 	//true if : dirty or paletted texture and revs don't match
@@ -342,17 +340,14 @@ struct TextureCacheData
 	
 	void Delete()
 	{
-#if 0
-      if (pData)
-      {
-         memalign_free(pData);
-         pData = 0;
-      }
-#endif
-		if (texID)
-      {
-         glDeleteTextures(1, &texID);
-      }
+		if (pData) {
+			_mm_free(pData);
+			pData = 0;
+		}
+
+		if (texID) {
+			glDeleteTextures(1, &texID);
+		}
 		if (lock_block)
 			libCore_vramlock_Unlock_block(lock_block);
 		lock_block=0;
diff --git a/core/rend/soft/softrend.cpp b/core/rend/soft/softrend.cpp
index d816d64..1229394 100644
--- a/core/rend/soft/softrend.cpp
+++ b/core/rend/soft/softrend.cpp
@@ -1,7 +1,7 @@
 #include <omp.h>
-#include "hw\pvr\Renderer_if.h"
-#include "hw\pvr\pvr_mem.h"
-#include "oslib\oslib.h"
+#include "hw/pvr/Renderer_if.h"
+#include "hw/pvr/pvr_mem.h"
+#include "oslib/oslib.h"
 
 /*
 	SSE/MMX based softrend
@@ -17,8 +17,9 @@
 #include <mmintrin.h>
 #include <xmmintrin.h>
 #include <emmintrin.h>
+#include <smmintrin.h>
 
-BITMAPINFOHEADER bi = { sizeof(BITMAPINFOHEADER), 0, 0, 1, 32, BI_RGB };
+#include <cmath>
 
 #include "rend/gles/gles.h"
 
@@ -34,7 +35,22 @@ u32 decoded_colors[3][65536];
 DECL_ALIGN(32) u32 render_buffer[MAX_RENDER_PIXELS * 2]; //Color + depth
 DECL_ALIGN(32) u32 pixels[MAX_RENDER_PIXELS];
 
+#if HOST_OS != OS_WINDOWS
 
+struct RECT {
+	int left, top, right, bottom;
+};
+
+#include     <X11/Xlib.h>
+#endif
+
+union m128i {
+	__m128i mm;
+	int8_t m128i_i8[16];
+	int16_t m128i_i16[8];
+	int32_t m128i_i32[4];
+	uint32_t m128i_u32[4];
+};
 
 static __m128 _mm_load_scaled_float(float v, float s)
 {
@@ -51,7 +67,7 @@ static __m128i _mm_broadcast_int(int v)
 }
 static __m128 _mm_load_ps_r(float a, float b, float c, float d)
 {
-	__declspec(align(128)) float v[4];
+	DECL_ALIGN(128) float v[4];
 	v[0] = a;
 	v[1] = b;
 	v[2] = c;
@@ -67,14 +83,14 @@ __forceinline int iround(float x)
 
 float mmin(float a, float b, float c, float d)
 {
-	int rv = min(a, b);
+	float rv = min(a, b);
 	rv = min(c, rv);
 	return max(d, rv);
 }
 
 float mmax(float a, float b, float c, float d)
 {
-	int rv = max(a, b);
+	float rv = max(a, b);
 	rv = max(c, rv);
 	return min(d, rv);
 }
@@ -237,11 +253,10 @@ typedef void(*RendtriangleFn)(PolyParam* pp, int vertex_offset, const Vertex &v1
 RendtriangleFn RendtriangleFns[3][2][2][2][4][2];
 
 
-__m128i const_setAlpha = { 0xFF000000, 0xFF000000, 0xFF000000, 0xFF000000, 0xFF000000 };
-__m128i shuffle_alpha = {
-	0x0E, 0x80, 0x0E, 0x80, 0x0E, 0x80, 0x0E, 0x80,
-	0x06, 0x80, 0x06, 0x80, 0x06, 0x80, 0x06, 0x80
-};
+__m128i const_setAlpha;
+
+__m128i shuffle_alpha;
+
 
 TPL_DECL_pixel
 static void PixelFlush(PolyParam* pp, text_info* texture, __m128 x, __m128 y, u8* cb, __m128 oldmask, IPs& ip)
@@ -303,8 +318,10 @@ static void PixelFlush(PolyParam* pp, text_info* texture, __m128 x, __m128 y, u8
 			__m128i vfi = _mm_cvttps_epi32(_mm_mul_ps(vf, _mm_set1_ps(256)));
 
 			//(int)v<<x+(int)u
-			__m128i textadr = _mm_add_epi32(_mm_slli_epi32(vi, 16), ui);//texture addresses ! 4x of em !
-			__m128i textel;
+			m128i textadr;
+
+			textadr.mm =  _mm_add_epi32(_mm_slli_epi32(vi, 16), ui);//texture addresses ! 4x of em !
+			m128i textel;
 
 			for (int i = 0; i < 4; i++) {
 				u32 u = textadr.m128i_i16[i * 2 + 0];
@@ -383,13 +400,13 @@ static void PixelFlush(PolyParam* pp, text_info* texture, __m128 x, __m128 y, u8
 			}
 
 			if (pp_IgnoreTexA) {
-				textel = _mm_or_si128(textel, const_setAlpha);
+				textel.mm = _mm_or_si128(textel.mm, const_setAlpha);
 			}
 
 			if (pp_ShadInstr == 0){
 					//color.rgb = texcol.rgb;
 					//color.a = texcol.a;
-				rv = textel;
+				rv = textel.mm;
 			}
 			else if (pp_ShadInstr == 1) {
 				//color.rgb *= texcol.rgb;
@@ -403,8 +420,8 @@ static void PixelFlush(PolyParam* pp, text_info* texture, __m128 x, __m128 y, u8
 				__m128i hi_rv = _mm_cvtepu8_epi16(_mm_shuffle_epi32(rv, _MM_SHUFFLE(1, 0, 3, 2)));
 
 
-				__m128i lo_fb = _mm_cvtepu8_epi16(textel);
-				__m128i hi_fb = _mm_cvtepu8_epi16(_mm_shuffle_epi32(textel, _MM_SHUFFLE(1, 0, 3, 2)));
+				__m128i lo_fb = _mm_cvtepu8_epi16(textel.mm);
+				__m128i hi_fb = _mm_cvtepu8_epi16(_mm_shuffle_epi32(textel.mm, _MM_SHUFFLE(1, 0, 3, 2)));
 
 
 				lo_rv = _mm_mullo_epi16(lo_rv, lo_fb);
@@ -420,8 +437,8 @@ static void PixelFlush(PolyParam* pp, text_info* texture, __m128 x, __m128 y, u8
 				__m128i hi_rv = _mm_cvtepu8_epi16(_mm_shuffle_epi32(rv, _MM_SHUFFLE(1, 0, 3, 2)));
 
 
-				__m128i lo_fb = _mm_cvtepu8_epi16(textel);
-				__m128i hi_fb = _mm_cvtepu8_epi16(_mm_shuffle_epi32(textel, _MM_SHUFFLE(1, 0, 3, 2)));
+				__m128i lo_fb = _mm_cvtepu8_epi16(textel.mm);
+				__m128i hi_fb = _mm_cvtepu8_epi16(_mm_shuffle_epi32(textel.mm, _MM_SHUFFLE(1, 0, 3, 2)));
 
 				__m128i lo_rv_alpha = _mm_shuffle_epi8(lo_fb, shuffle_alpha);
 				__m128i hi_rv_alpha = _mm_shuffle_epi8(hi_fb, shuffle_alpha);
@@ -444,8 +461,8 @@ static void PixelFlush(PolyParam* pp, text_info* texture, __m128 x, __m128 y, u8
 				__m128i hi_rv = _mm_cvtepu8_epi16(_mm_shuffle_epi32(rv, _MM_SHUFFLE(1, 0, 3, 2)));
 
 
-				__m128i lo_fb = _mm_cvtepu8_epi16(textel);
-				__m128i hi_fb = _mm_cvtepu8_epi16(_mm_shuffle_epi32(textel, _MM_SHUFFLE(1, 0, 3, 2)));
+				__m128i lo_fb = _mm_cvtepu8_epi16(textel.mm);
+				__m128i hi_fb = _mm_cvtepu8_epi16(_mm_shuffle_epi32(textel.mm, _MM_SHUFFLE(1, 0, 3, 2)));
 
 
 				lo_rv = _mm_mullo_epi16(lo_rv, lo_fb);
@@ -460,7 +477,7 @@ static void PixelFlush(PolyParam* pp, text_info* texture, __m128 x, __m128 y, u8
 			
 
 			//textadr = _mm_add_epi32(textadr, _mm_setr_epi32(tex_addr, tex_addr, tex_addr, tex_addr));
-			//rv = textel; // _mm_xor_si128(rv, textadr);
+			//rv = textel.mm; // _mm_xor_si128(rv, textadr);
 		}
 	}
 
@@ -471,12 +488,17 @@ static void PixelFlush(PolyParam* pp, text_info* texture, __m128 x, __m128 y, u8
 		__m128i fb = *(__m128i*)cb;
 
 #if 1
+		m128i mm_rv, mm_fb;
+		mm_rv.mm = rv;
+		mm_fb.mm = fb;
 		//ALPHA_TEST
 		for (int i = 0; i < 4; i++) {
-			if (rv.m128i_i8[i * 4 + 3] < PT_ALPHA_REF) {
-				rv.m128i_u32[i] = fb.m128i_u32[i];
+			if (mm_rv.m128i_i8[i * 4 + 3] < PT_ALPHA_REF) {
+				mm_rv.m128i_u32[i] = mm_fb.m128i_u32[i];
 			}
 		}
+
+		rv = mm_rv.mm;
 #else
 		__m128i ALPHA_TEST = _mm_set1_epi8(PT_ALPHA_REF);
 		__m128i mask = _mm_cmplt_epi8(_mm_subs_epu16(ALPHA_TEST, rv), _mm_setzero_si128());
@@ -673,15 +695,15 @@ static void Rendtriangle(PolyParam* pp, int vertex_offset, const Vertex &v1, con
 	u8* cb_y = (u8*)colorBuffer;
 	cb_y += miny*stride_bytes + minx*(q * 4);
 
-	IPs __declspec(align(64)) ip;
+	DECL_ALIGN(64) IPs ip;
 
 	ip.Setup(pp, &texture, v1, v2, v3, minx, miny, q);
 	
 	
 	__m128 y_ps = _mm_broadcast_float(miny);
 	__m128 minx_ps = _mm_load_scaled_float(minx - q, 1);
-	static __declspec(align(16)) float ones_ps[4] = { 1, 1, 1, 1 };
-	static __declspec(align(16)) float q_ps[4] = { q, q, q, q };
+	static DECL_ALIGN(16) float ones_ps[4] = { 1, 1, 1, 1 };
+	static DECL_ALIGN(16) float q_ps[4] = { q, q, q, q };
 
 	// Loop through blocks
 	for (int y = spany; y > 0; y -= q)
@@ -871,13 +893,22 @@ struct softrend : Renderer
 		return !is_rtt;
 	}
 
+#if HOST_OS == OS_WINDOWS
 	HWND hWnd;
 	HBITMAP hBMP = 0, holdBMP;
 	HDC hmem;
-	
 
+	BITMAPINFOHEADER bi = { sizeof(BITMAPINFOHEADER), 0, 0, 1, 32, BI_RGB };
+#endif
+	
 
 	virtual bool Init() {
+
+		const_setAlpha = _mm_set1_epi32(0xFF000000);
+		u8 ushuffle[] = { 0x0E, 0x80, 0x0E, 0x80, 0x0E, 0x80, 0x0E, 0x80, 0x06, 0x80, 0x06, 0x80, 0x06, 0x80, 0x06, 0x80};
+		memcpy(&shuffle_alpha, ushuffle, sizeof(shuffle_alpha));
+		
+#if HOST_OS == OS_WINDOWS
 		hWnd = (HWND)libPvr_GetRenderTarget();
 
 		bi.biWidth = 640;
@@ -897,6 +928,7 @@ struct softrend : Renderer
 		hmem = CreateCompatibleDC(hdc);
 		holdBMP = (HBITMAP)SelectObject(hmem, hBMP);
 		ReleaseDC(hWnd, hdc);
+#endif
 
 		#define REP_16(x) ((x)* 16 + (x))
 		#define REP_32(x) ((x)* 8 + (x)/4)
@@ -1116,10 +1148,20 @@ struct softrend : Renderer
 	}
 
 	virtual void Term() {
+#if HOST_OS == OS_WINDOWS
 		if (hBMP) {
 			DeleteObject(SelectObject(hmem, holdBMP));
 			DeleteDC(hmem);
 		}
+#endif
+	}
+
+	#define RR(x, a, b, c, d) (x + a), (x + b), (x + c), (x + d)
+	#define R(a, b, c, d) RR(12, a, b, c, d), RR(8, a, b, c, d), RR(4, a, b, c, d),  RR(0, a, b, c, d)
+
+	//R coefs should be adjusted to match pixel format
+	INLINE __m128 shuffle_pixel(__m128 v) {
+		return (__m128)_mm_shuffle_epi8((__m128i)v, _mm_set_epi8(R(0x80,2,1, 0)));
 	}
 
 	virtual void Present() {
@@ -1127,18 +1169,28 @@ struct softrend : Renderer
 		__m128* psrc = (__m128*)render_buffer;
 		__m128* pdst = (__m128*)pixels;
 
+		#define SHUFFL(v) v
+		//	#define SHUFFL(v) shuffle_pixel(v)
+
+		#if HOST_OS == OS_WINDOWS
+			#define FLIP_Y 479 - 
+		#else
+			#define FLIP_Y
+		#endif
+
 		const int stride = STRIDE_PIXEL_OFFSET / 4;
 		for (int y = 0; y<MAX_RENDER_HEIGHT; y += 4)
 		{
 			for (int x = 0; x<MAX_RENDER_WIDTH; x += 4)
 			{
-				pdst[(479 - (y + 0))*stride + x / 4] = *psrc++;
-				pdst[(479 - (y + 1))*stride + x / 4] = *psrc++;
-				pdst[(479 - (y + 2))*stride + x / 4] = *psrc++;
-				pdst[(479 - (y + 3))*stride + x / 4] = *psrc++;
+				pdst[(FLIP_Y (y + 0))*stride + x / 4] = SHUFFL(*psrc++);
+				pdst[(FLIP_Y (y + 1))*stride + x / 4] = SHUFFL(*psrc++);
+				pdst[(FLIP_Y (y + 2))*stride + x / 4] = SHUFFL(*psrc++);
+				pdst[(FLIP_Y (y + 3))*stride + x / 4] = SHUFFL(*psrc++);
 			}
 		}
 		
+#if HOST_OS == OS_WINDOWS
 		SetDIBits(hmem, hBMP, 0, 480, pixels, (BITMAPINFO*)&bi, DIB_RGB_COLORS);
 
 		RECT clientRect;
@@ -1153,9 +1205,27 @@ struct softrend : Renderer
 
 		BitBlt(hdc, x, y, 640 , 480 , hmem, 0, 0, SRCCOPY);
 		ReleaseDC(hWnd, hdc);
+#else
+		extern Window x11_win;
+		extern Display* x11_disp;
+		extern Visual* x11_vis;
+
+		int width = 640;
+		int height = 480;
+		
+		extern int x11_width;
+		extern int x11_height;
+
+		XImage* ximage = XCreateImage(x11_disp, x11_vis, 24, ZPixmap, 0, (char *)pixels, width, height, 32, width * 4);
+
+		GC gc = XCreateGC(x11_disp, x11_win, 0, 0);
+		XPutImage(x11_disp, x11_win, gc, ximage, 0, 0, (x11_width - width)/2, (x11_height - height)/2, width, height);
+		XFree(ximage);
+		XFreeGC(x11_disp, gc);
+#endif
 	}
 };
 
 Renderer* rend_softrend() {
 	return new(_mm_malloc(sizeof(softrend), 32)) softrend();
-}
\ No newline at end of file
+}
diff --git a/shell/linux/Makefile b/shell/linux/Makefile
index 82fc98e..4d6c5d4 100644
--- a/shell/linux/Makefile
+++ b/shell/linux/Makefile
@@ -70,7 +70,9 @@ else ifneq (,$(findstring x64,$(platform)))
 	 WITH_DYNAREC := x64
     USE_X11 := 1
     CFLAGS += -D TARGET_LINUX_x64 -D TARGET_NO_AREC -fsingle-precision-constant
+	 CFLAGS += -msse4.1
     CXXFLAGS += -fexceptions
+	 LDFLAGS += -fopenmp
 
 # Generic 32 bit ARMhf (a.k.a. ARMv7h)
 else ifneq (,$(findstring armv7h,$(platform)))
diff --git a/shell/linux/Makefile.common b/shell/linux/Makefile.common
index 14dda45..a18446a 100644
--- a/shell/linux/Makefile.common
+++ b/shell/linux/Makefile.common
@@ -89,6 +89,7 @@ SOURCES_CXX := $(CORE_DIR)/cfg/cfg.cpp \
 					$(CORE_DIR)/deps/chdpsr/cdipsr.cpp \
 					\
 					$(CORE_DIR)/rend/TexCache.cpp \
+					$(CORE_DIR)/rend/soft/softrend.cpp \
 					\
 					$(CORE_DIR)/reios/reios_elf.cpp \
 					$(CORE_DIR)/reios/reios.cpp \
