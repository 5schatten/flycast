diff --git a/core/hw/pvr/Renderer_if.cpp b/core/hw/pvr/Renderer_if.cpp
index d0bc5a3..2bc6d22 100644
--- a/core/hw/pvr/Renderer_if.cpp
+++ b/core/hw/pvr/Renderer_if.cpp
@@ -226,8 +226,8 @@ void rend_end_wait()
 bool rend_init(void)
 {
 
-#ifdef NO_REND
-	renderer	 = rend_norend();
+#if 1
+	renderer	 = rend_softrend();
 #else
 	renderer = rend_GLES2();
 #endif
diff --git a/core/rend/soft/softrend.cpp b/core/rend/soft/softrend.cpp
index d816d64..1229394 100644
--- a/core/rend/soft/softrend.cpp
+++ b/core/rend/soft/softrend.cpp
@@ -1,7 +1,7 @@
 #include <omp.h>
-#include "hw\pvr\Renderer_if.h"
-#include "hw\pvr\pvr_mem.h"
-#include "oslib\oslib.h"
+#include "hw/pvr/Renderer_if.h"
+#include "hw/pvr/pvr_mem.h"
+#include "oslib/oslib.h"
 
 /*
 	SSE/MMX based softrend
@@ -17,8 +17,9 @@
 #include <mmintrin.h>
 #include <xmmintrin.h>
 #include <emmintrin.h>
+#include <smmintrin.h>
 
-BITMAPINFOHEADER bi = { sizeof(BITMAPINFOHEADER), 0, 0, 1, 32, BI_RGB };
+#include <cmath>
 
 #include "rend/gles/gles.h"
 
@@ -34,7 +35,22 @@ u32 decoded_colors[3][65536];
 DECL_ALIGN(32) u32 render_buffer[MAX_RENDER_PIXELS * 2]; //Color + depth
 DECL_ALIGN(32) u32 pixels[MAX_RENDER_PIXELS];
 
+#if HOST_OS != OS_WINDOWS
 
+struct RECT {
+	int left, top, right, bottom;
+};
+
+#include     <X11/Xlib.h>
+#endif
+
+union m128i {
+	__m128i mm;
+	int8_t m128i_i8[16];
+	int16_t m128i_i16[8];
+	int32_t m128i_i32[4];
+	uint32_t m128i_u32[4];
+};
 
 static __m128 _mm_load_scaled_float(float v, float s)
 {
@@ -51,7 +67,7 @@ static __m128i _mm_broadcast_int(int v)
 }
 static __m128 _mm_load_ps_r(float a, float b, float c, float d)
 {
-	__declspec(align(128)) float v[4];
+	DECL_ALIGN(128) float v[4];
 	v[0] = a;
 	v[1] = b;
 	v[2] = c;
@@ -67,14 +83,14 @@ __forceinline int iround(float x)
 
 float mmin(float a, float b, float c, float d)
 {
-	int rv = min(a, b);
+	float rv = min(a, b);
 	rv = min(c, rv);
 	return max(d, rv);
 }
 
 float mmax(float a, float b, float c, float d)
 {
-	int rv = max(a, b);
+	float rv = max(a, b);
 	rv = max(c, rv);
 	return min(d, rv);
 }
@@ -237,11 +253,10 @@ typedef void(*RendtriangleFn)(PolyParam* pp, int vertex_offset, const Vertex &v1
 RendtriangleFn RendtriangleFns[3][2][2][2][4][2];
 
 
-__m128i const_setAlpha = { 0xFF000000, 0xFF000000, 0xFF000000, 0xFF000000, 0xFF000000 };
-__m128i shuffle_alpha = {
-	0x0E, 0x80, 0x0E, 0x80, 0x0E, 0x80, 0x0E, 0x80,
-	0x06, 0x80, 0x06, 0x80, 0x06, 0x80, 0x06, 0x80
-};
+__m128i const_setAlpha;
+
+__m128i shuffle_alpha;
+
 
 TPL_DECL_pixel
 static void PixelFlush(PolyParam* pp, text_info* texture, __m128 x, __m128 y, u8* cb, __m128 oldmask, IPs& ip)
@@ -303,8 +318,10 @@ static void PixelFlush(PolyParam* pp, text_info* texture, __m128 x, __m128 y, u8
 			__m128i vfi = _mm_cvttps_epi32(_mm_mul_ps(vf, _mm_set1_ps(256)));
 
 			//(int)v<<x+(int)u
-			__m128i textadr = _mm_add_epi32(_mm_slli_epi32(vi, 16), ui);//texture addresses ! 4x of em !
-			__m128i textel;
+			m128i textadr;
+
+			textadr.mm =  _mm_add_epi32(_mm_slli_epi32(vi, 16), ui);//texture addresses ! 4x of em !
+			m128i textel;
 
 			for (int i = 0; i < 4; i++) {
 				u32 u = textadr.m128i_i16[i * 2 + 0];
@@ -383,13 +400,13 @@ static void PixelFlush(PolyParam* pp, text_info* texture, __m128 x, __m128 y, u8
 			}
 
 			if (pp_IgnoreTexA) {
-				textel = _mm_or_si128(textel, const_setAlpha);
+				textel.mm = _mm_or_si128(textel.mm, const_setAlpha);
 			}
 
 			if (pp_ShadInstr == 0){
 					//color.rgb = texcol.rgb;
 					//color.a = texcol.a;
-				rv = textel;
+				rv = textel.mm;
 			}
 			else if (pp_ShadInstr == 1) {
 				//color.rgb *= texcol.rgb;
@@ -403,8 +420,8 @@ static void PixelFlush(PolyParam* pp, text_info* texture, __m128 x, __m128 y, u8
 				__m128i hi_rv = _mm_cvtepu8_epi16(_mm_shuffle_epi32(rv, _MM_SHUFFLE(1, 0, 3, 2)));
 
 
-				__m128i lo_fb = _mm_cvtepu8_epi16(textel);
-				__m128i hi_fb = _mm_cvtepu8_epi16(_mm_shuffle_epi32(textel, _MM_SHUFFLE(1, 0, 3, 2)));
+				__m128i lo_fb = _mm_cvtepu8_epi16(textel.mm);
+				__m128i hi_fb = _mm_cvtepu8_epi16(_mm_shuffle_epi32(textel.mm, _MM_SHUFFLE(1, 0, 3, 2)));
 
 
 				lo_rv = _mm_mullo_epi16(lo_rv, lo_fb);
@@ -420,8 +437,8 @@ static void PixelFlush(PolyParam* pp, text_info* texture, __m128 x, __m128 y, u8
 				__m128i hi_rv = _mm_cvtepu8_epi16(_mm_shuffle_epi32(rv, _MM_SHUFFLE(1, 0, 3, 2)));
 
 
-				__m128i lo_fb = _mm_cvtepu8_epi16(textel);
-				__m128i hi_fb = _mm_cvtepu8_epi16(_mm_shuffle_epi32(textel, _MM_SHUFFLE(1, 0, 3, 2)));
+				__m128i lo_fb = _mm_cvtepu8_epi16(textel.mm);
+				__m128i hi_fb = _mm_cvtepu8_epi16(_mm_shuffle_epi32(textel.mm, _MM_SHUFFLE(1, 0, 3, 2)));
 
 				__m128i lo_rv_alpha = _mm_shuffle_epi8(lo_fb, shuffle_alpha);
 				__m128i hi_rv_alpha = _mm_shuffle_epi8(hi_fb, shuffle_alpha);
@@ -444,8 +461,8 @@ static void PixelFlush(PolyParam* pp, text_info* texture, __m128 x, __m128 y, u8
 				__m128i hi_rv = _mm_cvtepu8_epi16(_mm_shuffle_epi32(rv, _MM_SHUFFLE(1, 0, 3, 2)));
 
 
-				__m128i lo_fb = _mm_cvtepu8_epi16(textel);
-				__m128i hi_fb = _mm_cvtepu8_epi16(_mm_shuffle_epi32(textel, _MM_SHUFFLE(1, 0, 3, 2)));
+				__m128i lo_fb = _mm_cvtepu8_epi16(textel.mm);
+				__m128i hi_fb = _mm_cvtepu8_epi16(_mm_shuffle_epi32(textel.mm, _MM_SHUFFLE(1, 0, 3, 2)));
 
 
 				lo_rv = _mm_mullo_epi16(lo_rv, lo_fb);
@@ -460,7 +477,7 @@ static void PixelFlush(PolyParam* pp, text_info* texture, __m128 x, __m128 y, u8
 			
 
 			//textadr = _mm_add_epi32(textadr, _mm_setr_epi32(tex_addr, tex_addr, tex_addr, tex_addr));
-			//rv = textel; // _mm_xor_si128(rv, textadr);
+			//rv = textel.mm; // _mm_xor_si128(rv, textadr);
 		}
 	}
 
@@ -471,12 +488,17 @@ static void PixelFlush(PolyParam* pp, text_info* texture, __m128 x, __m128 y, u8
 		__m128i fb = *(__m128i*)cb;
 
 #if 1
+		m128i mm_rv, mm_fb;
+		mm_rv.mm = rv;
+		mm_fb.mm = fb;
 		//ALPHA_TEST
 		for (int i = 0; i < 4; i++) {
-			if (rv.m128i_i8[i * 4 + 3] < PT_ALPHA_REF) {
-				rv.m128i_u32[i] = fb.m128i_u32[i];
+			if (mm_rv.m128i_i8[i * 4 + 3] < PT_ALPHA_REF) {
+				mm_rv.m128i_u32[i] = mm_fb.m128i_u32[i];
 			}
 		}
+
+		rv = mm_rv.mm;
 #else
 		__m128i ALPHA_TEST = _mm_set1_epi8(PT_ALPHA_REF);
 		__m128i mask = _mm_cmplt_epi8(_mm_subs_epu16(ALPHA_TEST, rv), _mm_setzero_si128());
@@ -673,15 +695,15 @@ static void Rendtriangle(PolyParam* pp, int vertex_offset, const Vertex &v1, con
 	u8* cb_y = (u8*)colorBuffer;
 	cb_y += miny*stride_bytes + minx*(q * 4);
 
-	IPs __declspec(align(64)) ip;
+	DECL_ALIGN(64) IPs ip;
 
 	ip.Setup(pp, &texture, v1, v2, v3, minx, miny, q);
 	
 	
 	__m128 y_ps = _mm_broadcast_float(miny);
 	__m128 minx_ps = _mm_load_scaled_float(minx - q, 1);
-	static __declspec(align(16)) float ones_ps[4] = { 1, 1, 1, 1 };
-	static __declspec(align(16)) float q_ps[4] = { q, q, q, q };
+	static DECL_ALIGN(16) float ones_ps[4] = { 1, 1, 1, 1 };
+	static DECL_ALIGN(16) float q_ps[4] = { q, q, q, q };
 
 	// Loop through blocks
 	for (int y = spany; y > 0; y -= q)
@@ -871,13 +893,22 @@ struct softrend : Renderer
 		return !is_rtt;
 	}
 
+#if HOST_OS == OS_WINDOWS
 	HWND hWnd;
 	HBITMAP hBMP = 0, holdBMP;
 	HDC hmem;
-	
 
+	BITMAPINFOHEADER bi = { sizeof(BITMAPINFOHEADER), 0, 0, 1, 32, BI_RGB };
+#endif
+	
 
 	virtual bool Init() {
+
+		const_setAlpha = _mm_set1_epi32(0xFF000000);
+		u8 ushuffle[] = { 0x0E, 0x80, 0x0E, 0x80, 0x0E, 0x80, 0x0E, 0x80, 0x06, 0x80, 0x06, 0x80, 0x06, 0x80, 0x06, 0x80};
+		memcpy(&shuffle_alpha, ushuffle, sizeof(shuffle_alpha));
+		
+#if HOST_OS == OS_WINDOWS
 		hWnd = (HWND)libPvr_GetRenderTarget();
 
 		bi.biWidth = 640;
@@ -897,6 +928,7 @@ struct softrend : Renderer
 		hmem = CreateCompatibleDC(hdc);
 		holdBMP = (HBITMAP)SelectObject(hmem, hBMP);
 		ReleaseDC(hWnd, hdc);
+#endif
 
 		#define REP_16(x) ((x)* 16 + (x))
 		#define REP_32(x) ((x)* 8 + (x)/4)
@@ -1116,10 +1148,20 @@ struct softrend : Renderer
 	}
 
 	virtual void Term() {
+#if HOST_OS == OS_WINDOWS
 		if (hBMP) {
 			DeleteObject(SelectObject(hmem, holdBMP));
 			DeleteDC(hmem);
 		}
+#endif
+	}
+
+	#define RR(x, a, b, c, d) (x + a), (x + b), (x + c), (x + d)
+	#define R(a, b, c, d) RR(12, a, b, c, d), RR(8, a, b, c, d), RR(4, a, b, c, d),  RR(0, a, b, c, d)
+
+	//R coefs should be adjusted to match pixel format
+	INLINE __m128 shuffle_pixel(__m128 v) {
+		return (__m128)_mm_shuffle_epi8((__m128i)v, _mm_set_epi8(R(0x80,2,1, 0)));
 	}
 
 	virtual void Present() {
@@ -1127,18 +1169,28 @@ struct softrend : Renderer
 		__m128* psrc = (__m128*)render_buffer;
 		__m128* pdst = (__m128*)pixels;
 
+		#define SHUFFL(v) v
+		//	#define SHUFFL(v) shuffle_pixel(v)
+
+		#if HOST_OS == OS_WINDOWS
+			#define FLIP_Y 479 - 
+		#else
+			#define FLIP_Y
+		#endif
+
 		const int stride = STRIDE_PIXEL_OFFSET / 4;
 		for (int y = 0; y<MAX_RENDER_HEIGHT; y += 4)
 		{
 			for (int x = 0; x<MAX_RENDER_WIDTH; x += 4)
 			{
-				pdst[(479 - (y + 0))*stride + x / 4] = *psrc++;
-				pdst[(479 - (y + 1))*stride + x / 4] = *psrc++;
-				pdst[(479 - (y + 2))*stride + x / 4] = *psrc++;
-				pdst[(479 - (y + 3))*stride + x / 4] = *psrc++;
+				pdst[(FLIP_Y (y + 0))*stride + x / 4] = SHUFFL(*psrc++);
+				pdst[(FLIP_Y (y + 1))*stride + x / 4] = SHUFFL(*psrc++);
+				pdst[(FLIP_Y (y + 2))*stride + x / 4] = SHUFFL(*psrc++);
+				pdst[(FLIP_Y (y + 3))*stride + x / 4] = SHUFFL(*psrc++);
 			}
 		}
 		
+#if HOST_OS == OS_WINDOWS
 		SetDIBits(hmem, hBMP, 0, 480, pixels, (BITMAPINFO*)&bi, DIB_RGB_COLORS);
 
 		RECT clientRect;
@@ -1153,9 +1205,27 @@ struct softrend : Renderer
 
 		BitBlt(hdc, x, y, 640 , 480 , hmem, 0, 0, SRCCOPY);
 		ReleaseDC(hWnd, hdc);
+#else
+		extern Window x11_win;
+		extern Display* x11_disp;
+		extern Visual* x11_vis;
+
+		int width = 640;
+		int height = 480;
+		
+		extern int x11_width;
+		extern int x11_height;
+
+		XImage* ximage = XCreateImage(x11_disp, x11_vis, 24, ZPixmap, 0, (char *)pixels, width, height, 32, width * 4);
+
+		GC gc = XCreateGC(x11_disp, x11_win, 0, 0);
+		XPutImage(x11_disp, x11_win, gc, ximage, 0, 0, (x11_width - width)/2, (x11_height - height)/2, width, height);
+		XFree(ximage);
+		XFreeGC(x11_disp, gc);
+#endif
 	}
 };
 
 Renderer* rend_softrend() {
 	return new(_mm_malloc(sizeof(softrend), 32)) softrend();
-}
\ No newline at end of file
+}
